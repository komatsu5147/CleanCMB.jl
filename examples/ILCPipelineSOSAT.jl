using CleanCMB
using Healpix, Libsharp
using PyCall
using Random, Statistics
using Printf
using Plots, LaTeXStrings
using Tables, CSV
# %% Create figures?
showresults = true

# %% Simulation parameters
nrz = 10 # How many realisations?
Random.seed!(5147) # Initial random number seed. Useful if you need reproducible sequence
rsim = 0 # Tensor-to-scalar ratio used for the simulation
Alens = 1 # Lensing power spectrum amplitude (Alens = 1 for the fiducial)
ℓmin, ℓmax = 30, 260 # ℓ range for fitting

# %% Specification of the experiment
# Reference: Simons Observatory Collaboration, JCAP, 02, 056 (2019), Table 1.
ν = [27, 39, 93, 145, 225, 280] # in GHz
nν = length(ν)
FWHM = [91, 63, 30, 17, 11, 9] # in arcmin
σ = FWHM * π / 10800 / √(8 * log(2)) # in radians
uKarcmin = [35, 21, 2.6, 3.3, 6.3, 16] # in μK arcmin (for temperature; x√2 for pol)
lknee = [30, 30, 50, 50, 70, 100]
αknee = [-2.4, -2.4, -2.5, -3, -3, -3]
# temperature beam
bTl(ℓ, σb) = exp(-ℓ * (ℓ + 1) * σb^2 / 2)
# polarisation beam, Eq.(5.8) of Ng & Liu, Int.J.Mod.Phys.D, 8, 61 (1999)
bPl(ℓ, σb) = ifelse(ℓ >= 2, exp(-(ℓ * (ℓ + 1) - 4) * σb^2 / 2), 0)

# %% Read in the hits map and calculate weights for inhomogeneous noise
nhitsfile = "data/nhits_SAT_r7.FITS"
nhits = readMapFromFITS(nhitsfile, 1, Float64)
nside = nhits.resolution.nside
nhits /= maximum(nhits)
fsky = mean(nhits)^2 / mean(nhits .^ 2)
K = √(mean(nhits) / fsky)
weight = zeros(12 * nside^2)
for ip = 1:12*nside^2
    if nhits[ip] > 0
        weight[ip] = K / √nhits[ip]
    end
end

# %% Compute scalar and tensor power spectra using CLASS
lmax, mmax = 3 * nside - 1, 3 * nside - 1
include("compute_cl_class.jl")

# %% Basic parameters for spherical harmonics transform
geom_info = make_healpix_geom_info(nside, 1)
alm_info = make_triangular_alm_info(lmax, mmax, 1)
elm, blm = Alm{ComplexF64}(lmax, mmax), Alm{ComplexF64}(lmax, mmax)

# %% Read in and smooth foreground maps generated by "d1s1" model of Python Sky Model (PySM), in equatorial coordinates
# Reference: Thorne et al., MNRAS, 469, 2821 (2017), https://github.com/healpy/pysm
f_q, f_u = [], []
for iν = 1:nν
    filename = @sprintf("data/map_d1s1_equ_%03dghz_r7_uKcmb_qu.fits", ν[iν])
    q, u = (readMapFromFITS(filename, ic, Float64) for ic = 1:2)
    sharp_execute!(
        SHARP_MAP2ALM,
        2,
        [elm.alm, blm.alm],
        [q.pixels, u.pixels],
        geom_info,
        alm_info,
        SHARP_DP,
    )
    for l = 0:lmax
        for m = 0:l
            ilm = alm_index(alm_info, l, m) + 1
            elm.alm[ilm] *= bPl(l, σ[iν])
            blm.alm[ilm] *= bPl(l, σ[iν])
        end
    end
    sharp_execute!(
        SHARP_ALM2MAP,
        2,
        [elm.alm, blm.alm],
        [q.pixels, u.pixels],
        geom_info,
        alm_info,
        SHARP_DP,
    )
    push!(f_q, q)
    push!(f_u, u)
end

# %% Setup NaMaster for the power spectrum analysis on a partial sky
Δℓ = 10 # multipole binning size
maskfile = "data/mask_apodized_r7.fits"
include("setup_namaster.jl")
# The theory power spectrum must be binned into bandpowers in the same manner the data has.
# Generate an NmtWorkspace object that we use to compute and store the mode coupling matrix.
# Note that this matrix depends only on the masks of the two fields to correlate, but not on the maps themselves.
w = nmt.NmtWorkspace()
f = nmt.NmtField(mask, [f_q[1], f_u[1]], purify_b = true)
w.compute_coupling_matrix(f, f, b)
cls_th = [cls["ee"], zero(cls["ee"]), zero(cls["bb"]), cls["bb"]] * Tcmb^2
cls_th_binned = w.decouple_cell(w.couple_cell(cls_th))
clt_th = [clt["ee"], zero(clt["ee"]), zero(clt["bb"]), clt["bb"]] * Tcmb^2
clt_th_binned = w.decouple_cell(w.couple_cell(clt_th))

# %% Compute covariance matrices of the foreground EE and BB
# Used to compute the power spectra of residual foreground for checking the results,
# but this information cannot be used for the real data analysis.
f3 = []
for iν = 1:nν
    push!(
        f3,
        nmt.NmtField(
            mask,
            [f_q[iν], f_u[iν]],
            purify_b = true,
            beam = bPl.(0:lmax, σ[iν]),
        ),
    )
end
ce3, cb3 = zeros(nν, nν, nbands), zeros(nν, nν, nbands) # foreground
for iν = 1:nν, jν = iν:nν
    w.compute_coupling_matrix(f3[iν], f3[jν], b)
    cl3 = compute_master(f3[iν], f3[jν], w)
    ce3[iν, jν, :], cb3[iν, jν, :] = cl3[1, :], cl3[4, :]
end

# %% Loop over realisations
ee1, bb1 = zeros(nbands, nrz), zeros(nbands, nrz) # Cleaned power spectra
ee2, bb2 = zeros(nbands, nrz), zeros(nbands, nrz) # Noise power spectra
ee3, bb3 = zeros(nbands, nrz), zeros(nbands, nrz) # Residual foreground power spectra
for irz = 1:nrz
    @show irz
    # Create spherical harmonics coefficients of the CMB
    for l = 2:lmax
        ee = cls_th[1][l+1] + (rsim / rclass) * clt_th[1][l+1]
        bb = Alens * cls_th[4][l+1] + (rsim / rclass) * clt_th[4][l+1]
        ilm = alm_index(alm_info, l, 0) + 1
        elm.alm[ilm] = √ee * randn(Float64)
        blm.alm[ilm] = √bb * randn(Float64)
        for m = 1:l
            ilm = alm_index(alm_info, l, m) + 1
            elm.alm[ilm] = √ee * randn(ComplexF64)
            blm.alm[ilm] = √bb * randn(ComplexF64)
        end
    end
    # Smooth CMB and create spherical harmonics coefficients of the noise
    celm, cblm = Alm{ComplexF64}(lmax, mmax), Alm{ComplexF64}(lmax, mmax)
    nelm, nblm = Alm{ComplexF64}(lmax, mmax), Alm{ComplexF64}(lmax, mmax)
    c_q, c_u = Map{Float64,RingOrder}(nside), Map{Float64,RingOrder}(nside)
    n_q, n_u = Map{Float64,RingOrder}(nside), Map{Float64,RingOrder}(nside)
    f1, f2 = [], [] # List of NaMaster fields
    for iν = 1:nν
        for l = 0:lmax
            ee =
                2 *
                (uKarcmin[iν] * π / 10800)^2 *
                (1 + (l / lknee[iν])^αknee[iν])
            bb =
                2 *
                (uKarcmin[iν] * π / 10800)^2 *
                (1 + (l / lknee[iν])^αknee[iν])
            if l >= 2
                ilm = alm_index(alm_info, l, 0) + 1
                celm.alm[ilm] = elm.alm[ilm] * bPl(l, σ[iν])
                cblm.alm[ilm] = blm.alm[ilm] * bPl(l, σ[iν])
                nelm.alm[ilm] = √ee * randn(Float64)
                nblm.alm[ilm] = √bb * randn(Float64)
                for m = 1:l
                    ilm = alm_index(alm_info, l, m) + 1
                    celm.alm[ilm] = elm.alm[ilm] * bPl(l, σ[iν])
                    cblm.alm[ilm] = blm.alm[ilm] * bPl(l, σ[iν])
                    nelm.alm[ilm] = √ee * randn(ComplexF64)
                    nblm.alm[ilm] = √bb * randn(ComplexF64)
                end
            else
                for m = 0:l
                    ilm = alm_index(alm_info, l, m) + 1
                    celm.alm[ilm], cblm.alm[ilm] = 0, 0
                    nelm.alm[ilm], nblm.alm[ilm] = 0, 0
                end
            end
        end
        sharp_execute!(
            SHARP_ALM2MAP,
            2,
            [celm.alm, cblm.alm],
            [c_q.pixels, c_u.pixels],
            geom_info,
            alm_info,
            SHARP_DP,
        )
        sharp_execute!(
            SHARP_ALM2MAP,
            2,
            [nelm.alm, nblm.alm],
            [n_q.pixels, n_u.pixels],
            geom_info,
            alm_info,
            SHARP_DP,
        )
        n_q .*= weight
        n_u .*= weight
        ## Create NaMaster fields for the pseudo-Cℓ
        # f1: foreground + CMB + noise
        push!(
            f1,
            nmt.NmtField(
                mask,
                [f_q[iν] + c_q + n_q, f_u[iν] + c_u + n_u],
                purify_b = true,
                beam = bPl.(0:lmax, σ[iν]),
            ),
        )
        # f2: noise
        push!(
            f2,
            nmt.NmtField(
                mask,
                [n_q, n_u],
                purify_b = true,
                beam = bPl.(0:lmax, σ[iν]),
            ),
        )
    end
    ## Compute covariance matrices of EE and BB
    ce1, cb1 = zeros(nν, nν, nbands), zeros(nν, nν, nbands) # total
    ce2, cb2 = zeros(nν, nν, nbands), zeros(nν, nν, nbands) # noise
    for iν = 1:nν, jν = iν:nν
        w.compute_coupling_matrix(f1[iν], f1[jν], b)
        cl1 = compute_master(f1[iν], f1[jν], w)
        cl2 = compute_master(f2[iν], f2[jν], w)
        ce1[iν, jν, :], cb1[iν, jν, :] = cl1[1, :], cl1[4, :]
        ce2[iν, jν, :], cb2[iν, jν, :] = cl2[1, :], cl2[4, :]
    end
    ## Perform ILC to obtain power spectra of clean maps of the CMB
    we, wb = ilc_weights(ce1), ilc_weights(cb1)
    ee1[:, irz], bb1[:, irz] = ilc_clean_cij(ce1, we), ilc_clean_cij(cb1, wb)
    ee2[:, irz], bb2[:, irz] = ilc_clean_cij(ce2, we), ilc_clean_cij(cb2, wb)
    ee3[:, irz], bb3[:, irz] = ilc_clean_cij(ce3, we), ilc_clean_cij(cb3, wb)
    # Show power spectra for visual inspection
    if showresults
        p = plot(
            ell_eff,
            cls_th_binned[1, :] .+ (rsim / rclass) * clt_th_binned[1, :],
            title = @sprintf("Realisation # = %03d", irz),
            label = "True EE",
            xaxis = :log,
            yaxis = :log,
            xlab = L"\ell",
            ylab = L"\ell(\ell+1)C_\ell/2\pi",
            ylims = [2e-5, 20],
            xlims = [ℓmin, ℓmax],
            legend = :topleft,
        )
        p = plot!(
            ell_eff,
            Alens * cls_th_binned[4, :] .+
            (rsim / rclass) * clt_th_binned[4, :],
            label = "True BB",
        )
        p = plot!(ell_eff, ee1[:, irz], m = :circle, lab = "Cleaned EE")
        p = plot!(ell_eff, bb1[:, irz], m = :circle, lab = "Cleaned BB")
        p = plot!(ell_eff, ee2[:, irz], m = :diamond, lab = "Noise EE")
        p = plot!(ell_eff, bb2[:, irz], m = :diamond, lab = "Noise BB")
        p = plot!(ell_eff, ee3[:, irz], m = :star5, lab = "FG EE")
        p = plot!(ell_eff, bb3[:, irz], m = :star5, lab = "FG BB")
        display(p)
    end
end

# %% Calculate the mean power spectra and variance
me1, mb1 = mean(ee1, dims = 2), mean(bb1, dims = 2)
ve1, vb1 = var(ee1, dims = 2), var(bb1, dims = 2)
me2, mb2 = mean(ee2, dims = 2), mean(bb2, dims = 2)
me3, mb3 = mean(ee3, dims = 2), mean(bb3, dims = 2)
# Plot and save to "ilc_clbb_sim_sosat.pdf"
ii = findall(x -> x >= ℓmin && x <= ℓmax, ell_eff)
if showresults
    p = scatter(
        ell_eff[ii],
        mb1[ii],
        m = 5,
        lab = "Cleaned power spectrum",
        xlab = L"\ell",
        ylab = L"\ell(\ell+1)C^{BB}_\ell/2\pi~[\mu K^2]",
        legend = :topleft,
    )
    p = scatter!(ell_eff[ii], mb1[ii] - mb2[ii], m = 5, lab = "- noisebias")
    p = scatter!(
        ell_eff[ii],
        mb1[ii] - mb2[ii] - mb3[ii],
        yerr = sqrt.(vb1[ii]),
        m = 5,
        lab = "- foreground",
    )
    p = plot!(ell_eff[ii], Alens * cls_th_binned[4, ii], lab = "Binned scalar")
    p = plot!(
        ell_eff[ii],
        (rsim / rclass) * clt_th_binned[4, ii],
        lab = "Binned tensor",
        ls = :dash,
    )
    savefig("ilc_clbb_sim_sosat.pdf")
    display(p)
end

# %% Calculate the tensor-to-scalar ratio
r = zeros(nrz)
w = zeros(nrz, 2)
# Joint fit for the tensor-to-scalar ratio and the foreground amplitude
y1 = clt_th_binned[4, ii] / rclass
y2 = mb3[ii]
v = vb1[ii]
Fij = [
    sum(y1 .* y1 ./ v) sum(y1 .* y2 ./ v)
    sum(y2 .* y1 ./ v) sum(y2 .* y2 ./ v)
] # 2x2 Fisher matrix for the tensor-to-scalar ratio and the foreground amplitude
Cij = inv(Fij) # Covariance matrix
for irz = 1:nrz
    x = bb1[ii, irz] .- mb2[ii] .- Alens * cls_th_binned[4, ii]
    r[irz] = sum(x .* y1 ./ v) / sum(y1 .^ 2 ./ v)
    z = [sum(x .* y1 ./ v), sum(x .* y2 ./ v)]
    w[irz, 1:2] = Fij \ z
end
# Report the final results
println("Fitted ℓs: ", ell_eff[ii])
println("Without foreground marginalisation:")
println("- r = ", mean(r), " ± ", std(r))
println("- Fisher error = ", 1 / √sum(y1 .^ 2 ./ v))
println("With foreground marginalisation:")
println("- r = ", mean(w[:, 1]), " ± ", std(w[:, 1]))
println("- Fisher error = ", √Cij[1, 1])
# println("- FG = ", mean(w[:, 2]), " ± ", std(w[:, 2]))
# println("- Fisher error = ", √Cij[2, 2])
# %% Save to the file
t = Tables.table([1:nrz r w[:, 1]])
CSV.write(
    "ilc_results_sosat.csv",
    t,
    header = ["irz", "r_wo_FGmarg", "r_w_FGmarg"],
)
